---
layout: default
---
====数据库水平切分模型=====

pinus的水平切分模型如下图所示，分为几个层级来表示，这个层级关系被配置在storage-config.xml文件中，配置文件中的节点名称为cluster
cluster可以配置多个，具体请参考入门教程中的配置文件信息。

{{:sharding_arch.png|}}

ShardingKey 分片因子，数据的增、删、改都需要通过这个因子来定位最终会存储在哪个库的哪张表中、ShardingKey的值在路由选择时会变成一个数字，如果是字符串也会通过hash算法变成一个数字。

cluster表示一个数据库集群，每个集群在配置的时候需要指定一个集群名称。

region表示一个数据库分组，每个region需要指定一个数字的范围，这个数值表示可以接受的ShardingKey的值得范围，这里需要注意的是，这个范围不是指具体的记录数，而是可以接受的ShardingKey的值

sharding表示一个分片库

sharding table表示一个分片库中的一个分表

global表示一个全局库，在一个集群当中只能存在一个全局库，全局库中的数据不会被切分。

global table 表示全局库中的表。

了解到以上概念之后下边描述一下具体的工作机制，首先在定义数据实体对象的时候我们需要对实体对象类使用@Table进行注解，@Table注解中有shardingBy、shardingNum、cluster等属性，这些属性表示这个数据实体是属于哪个集群的以及ShardingKey的值是依据那个字段的值产生的。当我们调用save方法保存这个对象时，pinus会首先给这个对象生成一个集群中唯一的主键（参考下一节：集群中数据主键生成），然后根据shardingBy所设定的字段取出值之后创建ShardingKey对象，DBRouter实例会根据给定的ShardingKey找到对应的一个数据库资源，然后将数据对象映射成SQL语句。

===数据扩容===
pinus目前只支持静态扩容，扩容的方式是依靠添加新的region来完成，结合上述的概念，每个region是有一组库组成，当某个集群的数据需要扩容时只需要添加新的region即可。

====集群中数据主键生成====

由于数据进行了水平分割，因此使用基于单表的主键自增方式就会出现问题，例如某个实体A被分了10张表，那么有可能会有10个主键是相同的记录，此时实体B在依靠A的主键进行切分时就会出现问题。

为了避免上述的情况发生，每个表记录的主键生成都需要交给一个单独的服务来处理，pinus选择了使用基于zookeeper来生成主键的服务，之所以选择zookeeper是出于以下几点考虑

1. zookeeper主要作用就是为了协调分布式系统、包括分布式存储，因此为分布式系统提供了很多特性

2. zookeeper自身就是分布式的因为容灾能力比较强

3. zookeeper本身的性能非常好，读写速度很快

4. zookeeper非常轻量，非常适合pinus的使用场景

其实网上也有很多其他的方式来生成主键。

===生成主键的机制===
在zookeeper中创建集群目录，集群目录中保存和表明相同的文件，每个文件的内容就是最后生成主键的数值。

====缓存机制====
pinus的缓存目前是基于memcached实现，用户可以通过实现IPrimaryCache和ISecondCache接口进行扩展

===一级缓存===

于数据库中的一条记录一 一对应，增、删、改、查操作会处理缓存与数据库的一致性，全局库中的数据的缓存与分片库中数据缓存的key值不同，但都是基于数据主键生成。

命中机制，当使用主键进行查询时会首先查询缓存，如果命中则直接返回，如果根据条件进行查询时，会首先根据查询条件从数据库中取出主键，之后从缓存中获取数据，如果部分主键没有命中缓存，则再将没有命中的主键通过in查询从数据库中查询，之后再将数据放入缓存中。

===二级缓存===

将对IQuery查询结果进行缓存，当增、删、改操作影响到缓存时，pinus会将缓存结果清除，缓存中的key是将IQuery对象通过hash操作生成唯一的字符串作为key。

命中机制，将新查询的IQuery通过相同的hash操作生成key，然后去缓存中查询，如果命中则直接返回，如果没有命中则查询数据库，将结果集进行缓存。

====事务机制====

pinus的事务涉及到多个数据库资源，因此属于分布式事务的范畴，但是需要特别说明的是，分布式事务是一种share everything的思想，分布式事务相关是一个非常广泛的话题，这里就不展开讨论，pinus没有使用2pc或者3pc来实现分布式事务，使用的是Best Efforts 1PC的方式来实现了JTA接口。
