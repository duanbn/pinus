/**
 * Copyright 2014 Duan Bingnan
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 *   
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.pinus4j.datalayer.update.jdbc;

import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;

import javax.transaction.TransactionManager;

import org.pinus4j.cache.IPrimaryCache;
import org.pinus4j.cache.ISecondCache;
import org.pinus4j.cluster.IDBCluster;
import org.pinus4j.datalayer.SQLBuilder;
import org.pinus4j.datalayer.update.IDataUpdate;
import org.pinus4j.entity.DefaultEntityMetaManager;
import org.pinus4j.entity.IEntityMetaManager;
import org.pinus4j.entity.meta.EntityPK;
import org.pinus4j.entity.meta.PKName;
import org.pinus4j.entity.meta.PKValue;
import org.pinus4j.utils.BeansUtil;
import org.pinus4j.utils.JdbcUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.Lists;

/**
 * 抽象的数据库更新操作组件.
 *
 * @author duanbn
 * @since 0.7.1
 */
public abstract class AbstractJdbcUpdate implements IDataUpdate {

    public static final Logger   LOG               = LoggerFactory.getLogger(AbstractJdbcUpdate.class);

    /**
     * 数据库集群引用
     */
    protected IDBCluster         dbCluster;

    /**
     * 一级缓存引用.
     */
    protected IPrimaryCache      primaryCache;

    /**
     * 二级缓存引用.
     */
    protected ISecondCache       secondCache;

    /**
     * 事务管理器
     */
    protected TransactionManager txManager;

    /**
     * 实体元信息管理器
     */
    protected IEntityMetaManager entityMetaManager = DefaultEntityMetaManager.getInstance();

    /**
     * 执行保存数据操作.
     *
     * @param conn 数据库连接
     * @param entities 需要被保存的数据
     * @param tableIndex 分片表下标. 当-1时忽略下标
     * @throws SQLException
     */
    protected List<PKValue> _saveBatchWithAutoGeneratedKeys(Connection conn, List<? extends Object> entities,
                                                            int tableIndex) throws SQLException {
        List<PKValue> pks = Lists.newArrayList();

        Statement st = null;
        String sql = null;

        Class<?> clazz = null;
        for (Object entity : entities) {
            try {
                st = conn.createStatement();
                sql = SQLBuilder.getInsert(entity, tableIndex);

                st.execute(sql, Statement.RETURN_GENERATED_KEYS);

                // 获取自增主键
                clazz = entity.getClass();
                if (!entityMetaManager.isUnionKey(clazz)) {
                    ResultSet rs = st.getGeneratedKeys();
                    PKName pkName = entityMetaManager.getNotUnionPkName(clazz);
                    Field f = BeansUtil.getField(clazz, pkName.getValue());
                    Object incrPK = null;
                    if (rs.next()) {
                        incrPK = rs.getObject(1);
                        if (f.getType() == Integer.TYPE || f.getType() == Integer.class) {
                            BeansUtil.setProperty(entity, pkName.getValue(), ((Long) incrPK).intValue());
                            pks.add(PKValue.valueOf(((Long) incrPK).intValue()));
                        } else {
                            BeansUtil.setProperty(entity, pkName.getValue(), incrPK);
                            pks.add(PKValue.valueOf(incrPK));
                        }
                    }
                }
            } finally {
                JdbcUtil.close(st);
            }
        }

        return pks;
    }

    /**
     * 批量保存数据，忽略自增主键.
     * 
     * @param conn
     * @param entities
     * @param tableIndex
     * @throws SQLException
     */
    protected int _saveBatchWithoutAutoGeneratedKeys(Connection conn, List<? extends Object> entities, int tableIndex)
            throws SQLException {
        int insertCount = 0;
        Statement st = null;
        try {
            st = conn.createStatement();

            for (Object entity : entities) {
                st.addBatch(SQLBuilder.getInsert(entity, tableIndex));
            }

            int[] insertCountArray = st.executeBatch();

            for (int i = 0; i < insertCountArray.length; i++) {
                insertCount += insertCountArray[i];
            }
        } finally {
            JdbcUtil.close(st);
        }

        return insertCount;
    }

    /**
     * @param tableIndex 等于-1时会被忽略.
     * @throws SQLException
     */
    protected int _removeByPks(Connection conn, List<EntityPK> pks, Class<?> clazz, int tableIndex) throws SQLException {
        int removeCount = 0;
        Statement st = null;
        try {
            st = conn.createStatement();

            st.addBatch((SQLBuilder.buildDeleteByPks(clazz, tableIndex, pks)));

            int[] removeCountArray = st.executeBatch();

            for (int i = 0; i < removeCountArray.length; i++) {
                removeCount = removeCountArray[i];
            }
        } finally {
            JdbcUtil.close(st);
        }

        return removeCount;
    }

    /**
     * @param tableIndex 等于-1时会被忽略.
     * @throws SQLException
     */
    protected int _updateBatch(Connection conn, List<? extends Object> entities, int tableIndex) throws SQLException {
        int updateCount = 0;
        Statement st = null;
        try {
            st = conn.createStatement();

            for (Object entity : entities) {
                st.addBatch(SQLBuilder.getUpdate(entity, tableIndex));
            }

            int[] updateCountArray = st.executeBatch();
            for (int i = 0; i < updateCountArray.length; i++) {
                updateCount += updateCountArray[i];
            }
        } finally {
            JdbcUtil.close(st);
        }

        return updateCount;
    }

    /**
     * 判断一级缓存是否可用
     * 
     * @return true:启用cache, false:不启用
     */
    protected boolean isCacheAvailable(Class<?> clazz) {
        return primaryCache != null && entityMetaManager.isCache(clazz);
    }

    /**
     * 判断二级缓存是否可用
     * 
     * @return true:启用cache, false:不启用
     */
    protected boolean isSecondCacheAvailable(Class<?> clazz) {
        return secondCache != null && entityMetaManager.isCache(clazz);
    }

    @Override
    public IDBCluster getDBCluster() {
        return dbCluster;
    }

    @Override
    public void setDBCluster(IDBCluster dbCluster) {
        this.dbCluster = dbCluster;
    }

    @Override
    public IPrimaryCache getPrimaryCache() {
        return primaryCache;
    }

    @Override
    public void setPrimaryCache(IPrimaryCache primaryCache) {
        this.primaryCache = primaryCache;
    }

    @Override
    public ISecondCache getSecondCache() {
        return secondCache;
    }

    @Override
    public void setSecondCache(ISecondCache secondCache) {
        this.secondCache = secondCache;
    }

    @Override
    public void setTransactionManager(TransactionManager txManager) {
        this.txManager = txManager;
    }

    @Override
    public TransactionManager getTransactionManager() {
        return this.txManager;
    }
}
